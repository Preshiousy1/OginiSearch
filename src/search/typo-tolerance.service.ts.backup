import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import { DataSource } from 'typeorm';
import { LightweightSymSpell } from './lightweight-symspell';

export interface Suggestion {
  text: string;
  score: number;
  freq: number;
  distance: number;
}

export interface TypoCorrection {
  originalQuery: string;
  correctedQuery: string;
  confidence: number;
  suggestions: Suggestion[];
  corrections: Array<{
    original: string;
    corrected: string;
    confidence: number;
  }>;
}

@Injectable()
export class TypoToleranceService {
  private readonly logger = new Logger(TypoToleranceService.name);
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  private similarityCache = new Map<string, { results: any; timestamp: number }>();
  private typoCheckCache = new Map<string, boolean>();
  private symSpell: LightweightSymSpell | null = null;
  private symSpellInitialized = false;

  constructor(private readonly dataSource: DataSource) {}

  /**
   * Initialize SymSpell for ultra-fast typo correction (lazy initialization)
   */
  private async initializeSymSpell(indexName: string): Promise<void> {
    if (this.symSpellInitialized) return;
    
    try {
      this.logger.log(`üöÄ Initializing SymSpell for index: ${indexName}`);
      this.symSpell = new LightweightSymSpell();
      
      // Load only the most common terms for faster initialization
      const terms = await this.dataSource.query(
        'SELECT term, total_frequency FROM search_terms WHERE index_name = $1 AND total_frequency >= 5 LIMIT 5000',
        [indexName]
      );
      
      for (const term of terms) {
        this.symSpell.add(term.term, term.total_frequency);
      }
      
      this.symSpellInitialized = true;
      this.logger.log(`‚úÖ SymSpell initialized with ${terms.length} terms for ${indexName}`);
    } catch (error) {
      this.logger.warn(`‚ö†Ô∏è SymSpell initialization failed: ${error.message}`);
      this.symSpell = null;
    }
  }

  /**
   * ULTRA-FAST typo tolerance with SymSpell + database fallback
   */
  async correctQuery(indexName: string, query: string, fields: string[]): Promise<TypoCorrection> {
    try {
      this.logger.log(`‚ö° Starting HYBRID typo tolerance for: "${query}" in ${indexName}`);

      // Check cache first for instant results
      const cacheKey = `hybrid:${indexName}:${query}:${fields.join(',')}`;
      const cached = this.similarityCache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
        this.logger.log(`üìã Using cached HYBRID results for: "${query}"`);
        return cached.results;
      }

      const startTime = Date.now();
      let suggestions: Suggestion[] = [];

      // Step 1: Try SymSpell first (ultra-fast - target 10ms)
      try {
        await this.initializeSymSpell(indexName);
        if (this.symSpell) {
          const symSpellSuggestions = this.symSpell.search(query);
          if (symSpellSuggestions.length > 0) {
            suggestions = symSpellSuggestions.map(s => ({
              text: s.term,
              score: s.count * 1000 - s.distance * 100,
              freq: s.count,
              distance: s.distance
            }));
            this.logger.log(`üöÄ SymSpell found ${suggestions.length} suggestions in ${Date.now() - startTime}ms`);
          }
        }
      } catch (error) {
        this.logger.warn(`‚ö†Ô∏è SymSpell lookup failed: ${error.message}`);
      }

      // Step 2: If SymSpell didn't find good results, use database fallback
      if (suggestions.length === 0 || suggestions[0].score < 500) {
        this.logger.log(`üîÑ SymSpell insufficient, using database fallback`);
        suggestions = await this.findUltraFastSuggestions(indexName, query, fields);
      }
      
      const processingTime = Date.now() - startTime;
      this.logger.log(`‚ö° HYBRID processing completed in ${processingTime}ms`);

      // Build the correction result
      const result = this.buildSimpleCorrection(query, suggestions);

      // Cache the results for future requests
      this.similarityCache.set(cacheKey, {
        results: result,
        timestamp: Date.now(),
      });

      return result;
    } catch (error) {
      this.logger.error(`‚ùå HYBRID typo tolerance error: ${error.message}`);
      return this.buildEmptyCorrection(query);
    }
  }

  /**
   * NEW: Optimized typo tolerance with parallel processing and worker threads
   * This method processes all fields simultaneously for much better performance
   */
  async correctQueryOptimized(
    indexName: string,
    query: string,
    fields: string[],
  ): Promise<TypoCorrection> {
    try {
      this.logger.log(`üöÄ Starting OPTIMIZED typo tolerance for: "${query}" in ${indexName}`);

      // Check cache first for instant results
      const cacheKey = `optimized:${indexName}:${query}:${fields.join(',')}`;
      const cached = this.similarityCache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
        this.logger.log(`üìã Using cached OPTIMIZED typo tolerance results for: "${query}"`);
        return cached.results;
      }

      // Process ALL fields in parallel for maximum performance
      const startTime = Date.now();
      const fieldPromises = fields.map(field =>
        this.processFieldOptimized(indexName, field, query),
      );

      // Wait for all fields to complete simultaneously
      const fieldResults = await Promise.all(fieldPromises);
      const processingTime = Date.now() - startTime;

      this.logger.log(`‚ö° Parallel processing completed in ${processingTime}ms`);

      // Use worker threads for CPU-intensive similarity calculations
      const enhancedResults = await this.enhanceWithWorkerThreads(fieldResults, query);
      const enhancementTime = Date.now() - startTime;

      this.logger.log(
        `üßµ Worker thread enhancement completed in ${enhancementTime - processingTime}ms`,
      );

      // Merge and deduplicate results efficiently
      const allTerms = enhancedResults.flat();
      const uniqueTerms = this.deduplicateTerms(allTerms);

      this.logger.log(`‚úÖ Found ${uniqueTerms.length} unique correction terms for "${query}"`);

      // Build the correction result
      const result = this.buildTypoCorrectionOptimized(query, uniqueTerms);

      // Cache the results for future requests
      this.similarityCache.set(cacheKey, {
        results: result,
        timestamp: Date.now(),
      });

      return result;
    } catch (error) {
      this.logger.error(`‚ùå Optimized typo tolerance error: ${error.message}`);
      // Fallback to the original method
      this.logger.log(`üîÑ Falling back to original typo tolerance method`);
      return this.correctQuery(indexName, query, fields);
    }
  }

  /**
   * Smart typo tolerance method that only runs when needed
   * NOTE: This method is now optimized since dictionary service already checks for typos
   */
  async correctQuerySmart(
    indexName: string,
    query: string,
    fields: string[],
  ): Promise<TypoCorrection> {
    // Since dictionary service already determined this is a typo, go straight to correction
    this.logger.log(`üöÄ Direct typo correction for: "${query}" (dictionary already confirmed typo)`);
    return this.correctQuerySimple(indexName, query, fields);
  }


  /**
   * SIMPLE, WORKING typo tolerance that actually works - now using ULTRA-FAST approach
   */
  async correctQuerySimple(
    indexName: string,
    query: string,
    fields: string[],
  ): Promise<TypoCorrection> {
    try {
      this.logger.log(`‚ö° Starting SIMPLE typo tolerance for: "${query}" in ${indexName}`);

      // Check cache first
      const cacheKey = `simple:${indexName}:${query}:${fields.join(',')}`;
      const cached = this.similarityCache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
        this.logger.log(`üìã Using cached SIMPLE typo tolerance results for: "${query}"`);
        return cached.results;
      }

      // Use the ULTRA-FAST approach for maximum speed
      const startTime = Date.now();
      const suggestions = await this.findUltraFastSuggestions(indexName, query, fields);
      const processingTime = Date.now() - startTime;

      this.logger.log(`‚ö° ULTRA-FAST processing completed in ${processingTime}ms`);

      // Build the correction result
      const result = this.buildSimpleCorrection(query, suggestions);

      // Cache the results
      this.similarityCache.set(cacheKey, {
        results: result,
        timestamp: Date.now(),
      });

      return result;
    } catch (error) {
      this.logger.error(`‚ùå Simple typo tolerance error: ${error.message}`);
      return this.buildEmptyCorrection(query);
    }
  }



  /**
   * Efficiently deduplicate terms while preserving field information
   */
  private deduplicateTerms(terms: any[]): any[] {
    const seen = new Set();
    return terms.filter(term => {
      if (!term || !term.term) return false;
      const key = term.term.toLowerCase();
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  /**
   * Get suggestions for a given input text from database field terms
   */
  async getSuggestions(
    indexName: string,
    field: string,
    inputText: string,
    size = 5,
  ): Promise<Suggestion[]> {
    try {
      this.logger.log(`üîç Getting suggestions for "${inputText}" in ${indexName}.${field}`);

      // Always use the new mathematical similarity approach
      // This is more efficient and accurate than the old field terms method
      const fieldTerms = await this.searchForCorrectionTerms(indexName, inputText, [field]);

      this.logger.log(`üìã Found ${fieldTerms.length} field terms for ${indexName}.${field}`);

      const suggestions = new Map<string, Suggestion>();

      // Process each term
      for (const term of fieldTerms) {
        if (!term || term.length < 2) continue;

        // Calculate Levenshtein distance for fuzzy matching
        const distance = this.levenshteinDistance(inputText.toLowerCase(), term.toLowerCase());
        const maxDistance = Math.min(3, Math.floor(term.length / 3));

        // More intelligent matching logic for typo tolerance
        // Accept terms that are similar to the input, not just exact matches
        let shouldAccept = false;
        let matchType = 'none';

        // 1. Exact matches (highest priority)
        if (term.toLowerCase() === inputText.toLowerCase()) {
          shouldAccept = true;
          matchType = 'exact';
        }
        // 2. Prefix matches (high priority)
        else if (term.toLowerCase().startsWith(inputText.toLowerCase())) {
          shouldAccept = true;
          matchType = 'prefix';
        }
        // 3. Substring matches (medium priority)
        else if (term.toLowerCase().includes(inputText.toLowerCase())) {
          shouldAccept = true;
          matchType = 'substring';
        }
        // 4. Fuzzy matches using mathematical similarity (new!)
        else if (term['combined_score'] && term['combined_score'] > 0.3) {
          shouldAccept = true;
          matchType = 'similarity';
        }
        // 5. Edit distance matches (fallback)
        else if (distance <= Math.max(2, Math.floor(inputText.length / 3))) {
          shouldAccept = true;
          matchType = 'fuzzy';
        }
        // 6. Soundex matches (phonetic)
        else if (term['soundex_sim'] === 1.0) {
          shouldAccept = true;
          matchType = 'soundex';
        }

        if (shouldAccept) {
          // Calculate score based on multiple factors - more aggressive approach
          let score = 0;

          // Base score by match type
          switch (matchType) {
            case 'exact':
              score += 300;
              break;
            case 'prefix':
              score += 150;
              break;
            case 'substring':
              score += 80;
              break;
            case 'similarity':
              score += 120;
              break;
            case 'fuzzy':
              score += 60;
              break;
            case 'soundex':
              score += 70;
              break;
          }

          // Use PostgreSQL's mathematical similarity scores if available
          if (term['combined_score']) {
            // Boost score based on similarity
            score += term['combined_score'] * 100;

            // Add bonus for high similarity
            if (term['combined_score'] > 0.7) score += 75;
            if (term['combined_score'] > 0.8) score += 100;
            if (term['combined_score'] > 0.9) score += 150;

            this.logger.log(
              `üéØ Mathematical similarity score: ${term['combined_score'].toFixed(
                3,
              )} for "${term}" (match type: ${matchType})`,
            );
          }

          // Adjust score based on term frequency (more common = better)
          const freq = this.estimateTermFrequency(term);
          score += Math.log1p(freq) * 15;

          // Adjust score based on length similarity (closer to input length = better)
          const lengthRatio =
            Math.min(term.length, inputText.length) / Math.max(term.length, inputText.length);
          score += lengthRatio * 30;

          // Bonus for generic category terms (higher frequency usually means generic categories)
          if (freq > 100) {
            score += 50; // Bonus for high-frequency terms (likely generic categories)
          }

          if (suggestions.size < 10) {
            // Log first 10 suggestions for debugging
            this.logger.log(
              `üí° Suggestion: "${term}" (score: ${score.toFixed(
                2,
              )}, distance: ${distance}, freq: ${freq}, matchType: ${matchType})`,
            );
          }

          suggestions.set(term, {
            text: term,
            score,
            freq,
            distance,
          });
        }
      }

      this.logger.log(`üìä Total suggestions found: ${suggestions.size}`);

      // Convert to array and sort by score
      const sortedSuggestions = Array.from(suggestions.values())
        .sort((a, b) => {
          // First by score
          const scoreDiff = b.score - a.score;
          if (scoreDiff !== 0) return scoreDiff;

          // Then by frequency if scores are equal
          const freqDiff = b.freq - a.freq;
          if (freqDiff !== 0) return freqDiff;

          // Finally by edit distance if both score and freq are equal
          return a.distance - b.distance;
        })
        .slice(0, size);

      this.logger.log(`‚úÖ Returning ${sortedSuggestions.length} suggestions for "${inputText}"`);
      return sortedSuggestions;
    } catch (error) {
      this.logger.error(`‚ùå Suggestion error: ${error.message}`);
      throw new BadRequestException(`Suggestion error: ${error.message}`);
    }
  }


  /**
   * Get cache statistics
   */
  getCacheStats(): { size: number; keys: string[] } {
    return {
      size: this.similarityCache.size,
      keys: Array.from(this.similarityCache.keys()),
    };
  }

  /**
   * Calculate Levenshtein distance between two strings
   */
  private levenshteinDistance(str1: string, str2: string): number {
    const m = str1.length;
    const n = str2.length;
    const dp: number[][] = Array(m + 1)
      .fill(null)
      .map(() => Array(n + 1).fill(0));

    // Initialize first row and column
    for (let i = 0; i <= m; i++) dp[i][0] = i;
    for (let j = 0; j <= n; j++) dp[0][j] = j;

    // Fill the matrix
    for (let i = 1; i <= m; i++) {
      for (let j = 1; j <= n; j++) {
        if (str1[i - 1] === str2[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1];
        } else {
          dp[i][j] =
            Math.min(
              dp[i - 1][j - 1], // substitution
              dp[i - 1][j], // deletion
              dp[i][j - 1], // insertion
            ) + 1;
        }
      }
    }

    return dp[m][n];
  }

  /**
   * Estimate term frequency based on common patterns and length
   */
  private estimateTermFrequency(term: string): number {
    // Business-specific common words
    const businessCommonWords = [
      'restaurant',
      'hotel',
      'salon',
      'shop',
      'store',
      'clinic',
      'hospital',
      'school',
      'university',
      'bank',
      'office',
      'company',
      'business',
      'service',
      'center',
      'market',
      'mall',
      'plaza',
      'complex',
      'food',
      'drink',
      'beauty',
      'health',
      'education',
      'finance',
      'technology',
      'consulting',
      'manufacturing',
      'retail',
      'wholesale',
    ];

    const lowerTerm = term.toLowerCase();

    if (businessCommonWords.includes(lowerTerm)) {
      return 1000; // High frequency for business terms
    }

    if (term.length <= 3) {
      return 500; // Short terms are often common
    }

    if (term.length <= 6) {
      return 100; // Medium length terms
    }

    return 10; // Longer terms are typically less frequent
  }

  /**
   * Clear the term cache
   */
  clearCache(): void {
    this.similarityCache.clear();
    this.logger.log('Term cache cleared');
  }

  /**
   * Build typo correction from results
   */
  private buildTypoCorrection(query: string, terms: any[]): TypoCorrection {
    if (!terms || terms.length === 0) {
      return this.buildEmptyCorrection(query);
    }

    // Process terms to find suggestions and corrections
    const suggestions = this.processTermsForSuggestions(query, terms);

    // Find the best correction
    const bestSuggestion = suggestions[0];
    const correctedQuery = bestSuggestion ? bestSuggestion.text : query;
    const confidence = bestSuggestion ? Math.min(0.95, bestSuggestion.score / 250) : 0;

    return {
      originalQuery: query,
      correctedQuery,
      confidence,
      suggestions,
      corrections: [
        {
          original: query,
          corrected: correctedQuery,
          confidence,
        },
      ],
    };
  }

  /**
   * Build empty correction when no suggestions found
   */
  private buildEmptyCorrection(query: string): TypoCorrection {
    return {
      originalQuery: query,
      correctedQuery: query,
      confidence: 1,
      suggestions: [],
      corrections: [],
    };
  }

  /**
   * Process terms to find suggestions with intelligent scoring
   */
  private processTermsForSuggestions(inputText: string, terms: any[]): Suggestion[] {
    const suggestions = new Map<string, Suggestion>();

    for (const term of terms) {
      if (!term || term.length < 2) continue;

      // Calculate Levenshtein distance
      const distance = this.levenshteinDistance(inputText.toLowerCase(), term.toLowerCase());

      // More intelligent matching logic for typo tolerance
      let shouldAccept = false;
      let matchType = 'none';

      // 1. Exact matches (highest priority)
      if (term.toLowerCase() === inputText.toLowerCase()) {
        shouldAccept = true;
        matchType = 'exact';
      }
      // 2. Prefix matches (high priority)
      else if (term.toLowerCase().startsWith(inputText.toLowerCase())) {
        shouldAccept = true;
        matchType = 'prefix';
      }
      // 3. Substring matches (medium priority)
      else if (term.toLowerCase().includes(inputText.toLowerCase())) {
        shouldAccept = true;
        matchType = 'substring';
      }
      // 4. Fuzzy matches using mathematical similarity
      else if (term['combined_score'] && term['combined_score'] > 0.3) {
        shouldAccept = true;
        matchType = 'similarity';
      }
      // 5. Edit distance matches (fallback)
      else if (distance <= Math.max(2, Math.floor(inputText.length / 3))) {
        shouldAccept = true;
        matchType = 'fuzzy';
      }
      // 6. Soundex matches (phonetic)
      else if (term['soundex_sim'] === 1.0) {
        shouldAccept = true;
        matchType = 'soundex';
      }

      if (shouldAccept) {
        // Calculate score based on multiple factors
        let score = 0;

        // Base score by match type
        switch (matchType) {
          case 'exact':
            score += 300;
            break;
          case 'prefix':
            score += 150;
            break;
          case 'substring':
            score += 80;
            break;
          case 'similarity':
            score += 120;
            break;
          case 'fuzzy':
            score += 60;
            break;
          case 'soundex':
            score += 70;
            break;
        }

        // Use PostgreSQL's mathematical similarity scores if available
        if (term['combined_score']) {
          score += term['combined_score'] * 100;

          if (term['combined_score'] > 0.7) score += 75;
          if (term['combined_score'] > 0.8) score += 100;
          if (term['combined_score'] > 0.9) score += 150;
        }

        // Adjust score based on term frequency
        const freq = this.estimateTermFrequency(term);
        score += Math.log1p(freq) * 15;

        // Bonus for generic category terms
        if (freq > 100) {
          score += 50;
        }

        suggestions.set(term, {
          text: term,
          score,
          freq,
          distance,
        });
      }
    }

    // Convert to array and sort by score
    return Array.from(suggestions.values())
      .sort((a, b) => b.score - a.score)
      .slice(0, 10);
  }

  /**
   * Build typo correction with optimized scoring
   */
  private buildTypoCorrectionOptimized(query: string, terms: any[]): TypoCorrection {
    if (!terms || terms.length === 0) {
      return this.buildEmptyCorrection(query);
    }

    // Process terms with optimized scoring
    const suggestions = this.processTermsOptimized(query, terms);

    // Find the best correction
    const bestSuggestion = suggestions[0];
    const correctedQuery = bestSuggestion ? bestSuggestion.text : query;
    const confidence = bestSuggestion ? Math.min(0.95, bestSuggestion.score / 200) : 0;

    return {
      originalQuery: query,
      correctedQuery,
      confidence,
      suggestions,
      corrections: [
        {
          original: query,
          corrected: correctedQuery,
          confidence,
        },
      ],
    };
  }

  /**
   * Process terms with optimized scoring algorithm
   */
  private processTermsOptimized(inputText: string, terms: any[]): Suggestion[] {
    const suggestions = new Map<string, Suggestion>();

    for (const term of terms) {
      if (!term || !term.term || term.term.length < 2) continue;

      const termText = term.term;
      const distance =
        term.distance || this.levenshteinDistance(inputText.toLowerCase(), termText.toLowerCase());
      const frequency = term.frequency || 1;

      // FIXED: Prioritize relevance over frequency
      let score = 0;

      // Base score by match type (HIGHEST PRIORITY)
      if (termText.toLowerCase() === inputText.toLowerCase()) {
        score += 500; // Exact match - highest priority
      } else if (termText.toLowerCase().startsWith(inputText.toLowerCase())) {
        score += 400; // Prefix match - very high priority
      } else if (termText.toLowerCase().includes(inputText.toLowerCase())) {
        score += 300; // Substring match - high priority
      } else if (distance <= 1) {
        score += 350; // Very close edit distance - high priority
      } else if (distance <= 2) {
        score += 250; // Close edit distance - medium-high priority
      } else if (distance <= 3) {
        score += 150; // Medium edit distance - medium priority
      }

      // Phonetic similarity bonus (using soundex-like logic)
      if (this.isPhoneticallySimilar(inputText, termText)) {
        score += 200; // High bonus for phonetic similarity
      }

      // Frequency bonus (REDUCED PRIORITY)
      score += Math.log1p(frequency) * 5; // Reduced from 20 to 5

      // Distance penalty (INCREASED)
      score -= distance * 25; // Increased from 10 to 25

      // Length similarity bonus
      const lengthDiff = Math.abs(termText.length - inputText.length);
      score -= lengthDiff * 5;

      if (score > 0) {
        suggestions.set(termText, {
          text: termText,
          score,
          freq: frequency,
          distance,
        });
      }
    }

    // Return top suggestions sorted by score
    return Array.from(suggestions.values())
      .sort((a, b) => b.score - a.score)
      .slice(0, 10);
  }

  /**
   * Check if two terms are phonetically similar
   */
  private isPhoneticallySimilar(str1: string, str2: string): boolean {
    const s1 = str1.toLowerCase();
    const s2 = str2.toLowerCase();

    // Simple phonetic rules for common typos
    if (s1 === s2) return true;

    // Common phonetic patterns
    const patterns = [
      { from: 'ph', to: 'f' },
      { from: 'ck', to: 'k' },
      { from: 'qu', to: 'kw' },
      { from: 'x', to: 'ks' },
      { from: 'z', to: 's' },
      { from: 'c', to: 'k' },
      { from: 's', to: 'z' },
      { from: 'f', to: 'ph' },
      { from: 'k', to: 'c' },
      { from: 't', to: 'd' },
      { from: 'd', to: 't' },
      { from: 'b', to: 'p' },
      { from: 'p', to: 'b' },
      { from: 'g', to: 'j' },
      { from: 'j', to: 'g' },
      { from: 'l', to: 'r' },
      { from: 'r', to: 'l' },
      { from: 'm', to: 'n' },
      { from: 'n', to: 'm' },
      { from: 'v', to: 'w' },
      { from: 'w', to: 'v' },
    ];

    // Check if applying any phonetic pattern makes them similar
    for (const pattern of patterns) {
      const modified1 = s1.replace(new RegExp(pattern.from, 'g'), pattern.to);
      const modified2 = s2.replace(new RegExp(pattern.from, 'g'), pattern.to);

      if (
        modified1 === modified2 ||
        modified1.includes(modified2) ||
        modified2.includes(modified1)
      ) {
        return true;
      }
    }

    return false;
  }


  /**
   * Calculate character-level similarity for single words (PERFECT for typo detection)
   */
  private calculateCharacterSimilarity(str1: string, str2: string): number {
    if (str1 === str2) return 1.0;

    // Normalize strings
    const s1 = str1.toLowerCase().trim();
    const s2 = str2.toLowerCase().trim();

    // Calculate Levenshtein distance
    const distance = this.levenshteinDistance(s1, s2);
    const maxLength = Math.max(s1.length, s2.length);

    // Convert distance to similarity (0-1 scale)
    const similarity = Math.max(0, 1 - distance / maxLength);

    // Boost for common typo patterns
    if (distance === 1 && this.isCommonTypo(s1, s2)) {
      return Math.min(1.0, similarity + 0.2);
    }

    return similarity;
  }

  /**
   * Check if two words follow common typo patterns
   */
  private isCommonTypo(str1: string, str2: string): boolean {
    const s1 = str1.toLowerCase();
    const s2 = str2.toLowerCase();

    // Common character substitutions
    const commonSubs = [
      ['m', 'n'],
      ['n', 'm'],
      ['b', 'p'],
      ['p', 'b'],
      ['d', 't'],
      ['t', 'd'],
      ['g', 'j'],
      ['j', 'g'],
      ['c', 'k'],
      ['k', 'c'],
      ['s', 'z'],
      ['z', 's'],
      ['f', 'ph'],
      ['ph', 'f'],
      ['ck', 'k'],
      ['k', 'ck'],
    ];

    for (const [from, to] of commonSubs) {
      if (s1.replace(new RegExp(from, 'g'), to) === s2) return true;
      if (s2.replace(new RegExp(from, 'g'), to) === s1) return true;
    }

    return false;
  }

  /**
   * Calculate word similarity (simplified version)
   */
  private calculateWordSimilarity(str1: string, str2: string): number {
    if (str1 === str2) return 1.0;

    const words1 = str1.toLowerCase().split(/\s+/);
    const words2 = str2.toLowerCase().split(/\s+/);

    const intersection = words1.filter(word => words2.includes(word));
    const union = [...new Set([...words1, ...words2])];

    return union.length > 0 ? intersection.length / union.length : 0.0;
  }

  /**
   * Calculate combined similarity score
   */
  private calculateCombinedScore(
    query: string,
    term: string,
    distance: number,
    frequency: number,
  ): number {
    const trigramSim = this.calculateTrigramSimilarity(query, term);
    const wordSim = this.calculateWordSimilarity(query, term);

    // Weighted combination
    return trigramSim * 0.4 + wordSim * 0.4 + (1 - distance / 10) * 0.2;
  }

  /**
   * ULTRA-FAST suggestions using optimized database functions
   */
  private async findUltraFastSuggestions(
    indexName: string,
    query: string,
    fields: string[],
  ): Promise<Suggestion[]> {
    // Temporarily force direct document search to ensure we find all matches
    this.logger.log(`üîç Using direct document search for "${query}" (bypassing materialized view for debugging)`);
    return this.findDirectDocumentSuggestions(indexName, query, fields);
  }

  /**
   * Direct document search - more comprehensive fallback
   */
  private async findDirectDocumentSuggestions(
    indexName: string,
    query: string,
    fields: string[],
  ): Promise<Suggestion[]> {
    const allSuggestions: Suggestion[] = [];

    this.logger.log(`üîç Using direct document search for "${query}"`);

    // Focus on the most important fields first (name, title) for better performance
    const priorityFields = fields.filter(f => ['name', 'title'].includes(f));
    const otherFields = fields.filter(f => !['name', 'title'].includes(f));
    const orderedFields = [...priorityFields, ...otherFields];
    
    // Process fields in parallel but limit to top 3 for speed
    const fieldsToProcess = orderedFields.slice(0, 3);
    
    const fieldPromises = fieldsToProcess.map(async (field) => {
      try {
        const directQuery = `
          SELECT DISTINCT 
            d.content->>'${field}' as term,
            COUNT(*) as frequency,
            similarity($2, d.content->>'${field}') as trigram_sim,
            levenshtein($2, d.content->>'${field}') as lev_distance,
            word_similarity($2, d.content->>'${field}') as word_sim,
            GREATEST(similarity($2, d.content->>'${field}'), word_similarity($2, d.content->>'${field}')) as max_sim
          FROM documents d
          WHERE d.index_name = $1
            AND d.content->>'${field}' IS NOT NULL
            AND LENGTH(d.content->>'${field}') BETWEEN 3 AND 50
            AND d.content->>'${field}' NOT LIKE '%<%'
            AND (
              similarity($2, d.content->>'${field}') > 0.15
              OR word_similarity($2, d.content->>'${field}') > 0.15
              OR levenshtein($2, d.content->>'${field}') <= 3
              OR d.content->>'${field}' ILIKE $2 || '%'
            )
          GROUP BY d.content->>'${field}', trigram_sim, lev_distance, word_sim, max_sim
          ORDER BY 
            max_sim DESC,
            lev_distance ASC,
            COUNT(*) DESC
          LIMIT 8
        `;

        const results = await this.dataSource.query(directQuery, [indexName, query]);
        this.logger.log(`üîç Field ${field}: Found ${results.length} direct results for "${query}"`);

        const fieldSuggestions: Suggestion[] = results
          .map(row => {
            const score = this.calculateOptimizedScore(
              query,
              row.term,
              row.trigram_sim,
              row.lev_distance,
              row.frequency
            );
            
            return {
              text: row.term,
              score,
              freq: row.frequency,
              distance: row.lev_distance
            };
          })
          .filter(suggestion => this.isRelevantMatch(query, suggestion.text, suggestion.score/1000, suggestion.distance));
        
        fieldSuggestions.forEach(suggestion => {
          this.logger.log(`üîç Direct match: "${suggestion.text}" (score: ${suggestion.score.toFixed(1)}, sim: ${(suggestion.score/1000).toFixed(3)}, word: ${(suggestion.score/1000).toFixed(3)}, dist: ${suggestion.distance})`);
        });
        
        return fieldSuggestions;
      } catch (error) {
        this.logger.warn(`‚ö†Ô∏è Direct document search failed for field ${field}: ${error.message}`);
        return [];
      }
    });

    // Wait for all fields to complete
    const fieldResults = await Promise.all(fieldPromises);
    
    // Combine all suggestions
    for (const fieldSuggestions of fieldResults) {
      allSuggestions.push(...fieldSuggestions);
    }

    return allSuggestions.sort((a, b) => b.score - a.score).slice(0, 5);
  }


  /**
   * Calculate optimized score for suggestions
   */
  private calculateOptimizedScore(
    query: string,
    term: string,
    similarity: number,
    editDistance: number,
    frequency: number
  ): number {
    let score = similarity * 1000; // Base similarity score
    
    // Edit distance penalty (reduced)
    score -= editDistance * 50;  // Reduced from 100 to 50
    
    // Frequency bonus (increased)
    score += Math.log1p(frequency) * 100;  // Increased from 50 to 100
    
    // Prefix bonus (increased)
    if (term.toLowerCase().startsWith(query.toLowerCase())) {
      score += 300;  // Increased from 200 to 300
    }
    
    // Exact match bonus (increased)
    if (term.toLowerCase() === query.toLowerCase()) {
      score += 600;  // Increased from 500 to 600
    }
    
    // Special bonus for common typo patterns
    if (editDistance <= 2 && similarity > 0.3) {
      score += 200;  // Bonus for likely typos
    }
    
    return Math.max(0, score);
  }

  /**
   * Check if a match is relevant enough to include in suggestions (SMART version)
   */
  private isRelevantMatch(query: string, term: string, trigramSim: number, levDistance: number): boolean {
    const queryLower = query.toLowerCase();
    const termLower = term.toLowerCase();

    // Always include exact matches
    if (queryLower === termLower) return true;

    // Include high similarity matches
    if (trigramSim > 0.5) return true;

    // Include prefix matches
    if (termLower.startsWith(queryLower)) return true;

    // Include close edit distance matches (likely typos)
    if (levDistance <= 2) return true;

    // Include soundex matches for phonetic similarity
    if (this.isSoundexMatch(query, term)) return true;

    // For longer queries, be more lenient with similarity
    if (query.length > 6 && trigramSim > 0.25) return true;

    // For shorter queries, be more strict
    if (query.length <= 6 && trigramSim < 0.4) return false;

    // Reject matches where the length difference is too large
    const lengthDiff = Math.abs(term.length - query.length);
    if (lengthDiff > Math.max(4, query.length / 2)) return false;

    return false; // Default to reject for safety
  }

  /**
   * Simple soundex match check
   */
  private isSoundexMatch(str1: string, str2: string): boolean {
    try {
      // Use PostgreSQL's soundex function if available, otherwise simple phonetic check
      return this.simpleSoundex(str1) === this.simpleSoundex(str2);
    } catch {
      return false;
    }
  }

  /**
   * Simple soundex implementation
   */
  private simpleSoundex(str: string): string {
    const s = str.toLowerCase().replace(/[^a-z]/g, '');
    if (s.length === 0) return '0000';
    
    let result = s[0].toUpperCase();
    const replacements = {
      'b': '1', 'f': '1', 'p': '1', 'v': '1',
      'c': '2', 'g': '2', 'j': '2', 'k': '2', 'q': '2', 's': '2', 'x': '2', 'z': '2',
      'd': '3', 't': '3',
      'l': '4',
      'm': '5', 'n': '5',
      'r': '6'
    };
    
    let prev = '';
    for (let i = 1; i < s.length && result.length < 4; i++) {
      const char = s[i];
      const replacement = replacements[char] || '';
      if (replacement && replacement !== prev) {
        result += replacement;
        prev = replacement;
      }
    }
    
    return result.padEnd(4, '0');
  }

  /**
   * ULTRA-FAST suggestions using optimized database functions
   */
  private async findUltraFastSuggestions(
    indexName: string,
    query: string,
    fields: string[],
  ): Promise<Suggestion[]> {
    const allSuggestions: Suggestion[] = [];

    for (const field of fields) {
      try {
        // Use the EXACT query that we know works from our direct database test
        const directQuery = `
          SELECT DISTINCT 
            d.content->>'${field}' as term,
            COUNT(*) as frequency,
            similarity($2, d.content->>'${field}') as similarity_score,
            CASE WHEN soundex($2) = soundex(d.content->>'${field}') THEN true ELSE false END as soundex_match
          FROM documents d
          WHERE d.index_name = $1 
            AND d.content->>'${field}' IS NOT NULL
            AND LENGTH(d.content->>'${field}') > 2
            AND LENGTH(d.content->>'${field}') < 100
            AND d.content->>'${field}' NOT LIKE '%<%'
            AND (
              soundex($2) = soundex(d.content->>'${field}')
              OR d.content->>'${field}' ILIKE '%' || $2 || '%'
              OR similarity($2, d.content->>'${field}') > 0.1
            )
          GROUP BY d.content->>'${field}'
          ORDER BY similarity_score DESC, COUNT(*) DESC
          LIMIT 10
        `;

        this.logger.log(`üîç Executing direct query for field ${field}`);
        const results = await this.dataSource.query(directQuery, [indexName, query]);

        this.logger.log(`üìä Field ${field}: Found ${results.length} results for "${query}"`);
        if (results.length > 0) {
          this.logger.log(
            `üìä Top results: ${results
              .slice(0, 3)
              .map(r => `${r.term} (sim: ${r.similarity_score})`)
              .join(', ')}`,
          );
        }

        for (const row of results) {
          const term = row.term;
          const frequency = parseInt(row.frequency);
          const distance = this.levenshteinDistance(query.toLowerCase(), term.toLowerCase());

          // Calculate a simple score
          let score = 0;

          // Soundex match gets highest score
          if (row.soundex_match) {
            score += 500;
          }

          // Substring match
          if (term.toLowerCase().includes(query.toLowerCase())) {
            score += 300;
          }

          // SIMPLE, WORKING word-level similarity scoring
          const words = term.split(/\s+/).filter(word => word.length > 2);
          this.logger.log(
            `üîç Word extraction for "${term}": extracted words=[${words.join(', ')}]`,
          );

          let bestWordScore = 0;
          let bestWord = '';

          for (const word of words) {
            // SIMPLE, WORKING CHARACTER-LEVEL similarity calculation
            const wordSimilarity = this.calculateCharacterSimilarity(query, word);
            this.logger.log(
              `üîç Word similarity: "${query}" vs "${word}" = ${wordSimilarity.toFixed(3)}`,
            );
            if (wordSimilarity > bestWordScore) {
              bestWordScore = wordSimilarity;
              bestWord = word;
            }
          }

          // DEBUG: Log word-level similarity scores
          this.logger.log(
            `üîç Word-level scoring for "${term}": best word="${bestWord}", similarity=${bestWordScore.toFixed(
              3,
            )}`,
          );

          // Use the best word similarity for scoring
          if (bestWordScore > 0.7) score += 1000; // Excellent word match
          else if (bestWordScore > 0.5) score += 800; // Good word match
          else if (bestWordScore > 0.3) score += 600; // Decent word match
          else if (bestWordScore > 0.1) score += 400; // Weak word match

          // Fallback to whole-term similarity if no good word matches
          if (bestWordScore < 0.1 && row.similarity_score > 0.3) {
            score += 200;
          }

          // Distance penalty - REDUCED PENALTY
          score -= distance * 20; // Reduced from 50 to 20

          // Frequency bonus (small)
          score += Math.log1p(frequency) * 10;

          // DEBUG: Log the scoring for each term
          this.logger.log(
            `üîç Scoring "${term}": base=${score}, sim=${row.similarity_score}, distance=${distance}, freq=${frequency}, final=${score}`,
          );

          if (score > 0) {
            allSuggestions.push({
              text: term,
              score,
              freq: frequency,
              distance,
            });
          } else {
            this.logger.log(`‚ùå Term "${term}" filtered out with score ${score}`);
          }
        }
      } catch (error) {
        this.logger.warn(`‚ö†Ô∏è Failed to process field ${field}: ${error.message}`);
      }
    }

    // Sort by score and return top suggestions
    return allSuggestions.sort((a, b) => b.score - a.score).slice(0, 10);
  }

  /**
   * Find suggestions using a simple, direct approach
   */
  private async findSimpleSuggestions(
    indexName: string,
    query: string,
    fields: string[],
  ): Promise<Suggestion[]> {
    const allSuggestions: Suggestion[] = [];

    for (const field of fields) {
      try {
        // Simple query that finds relevant terms with similarity scores
        const simpleQuery = `
          SELECT DISTINCT 
            d.content->>'${field}' as term,
            COUNT(*) as frequency,
            similarity($2, d.content->>'${field}') as similarity_score,
            CASE WHEN soundex($2) = soundex(d.content->>'${field}') THEN true ELSE false END as soundex_match
          FROM documents d
          WHERE d.index_name = $1 
            AND d.content->>'${field}' IS NOT NULL
            AND LENGTH(d.content->>'${field}') > 2
            AND LENGTH(d.content->>'${field}') < 100
            AND d.content->>'${field}' NOT LIKE '%<%'
            AND (
              -- Soundex matching (very effective for typos)
              soundex($2) = soundex(d.content->>'${field}')
              -- Substring matching
              OR d.content->>'${field}' ILIKE '%' || $2 || '%'
              -- Basic similarity (very low threshold to catch all potential matches)
              OR similarity($2, d.content->>'${field}') > 0.1
            )
          GROUP BY d.content->>'${field}'
          ORDER BY COUNT(*) DESC
          LIMIT 10
        `;

        const results = await this.dataSource.query(simpleQuery, [indexName, query]);

        this.logger.log(`üîç Field ${field}: Found ${results.length} results for "${query}"`);
        if (results.length > 0) {
          this.logger.log(
            `üìä Top results: ${results
              .slice(0, 3)
              .map(r => `${r.term} (sim: ${r.similarity_score})`)
              .join(', ')}`,
          );
        }

        for (const row of results) {
          const term = row.term;
          const frequency = parseInt(row.frequency);
          const distance = this.levenshteinDistance(query.toLowerCase(), term.toLowerCase());

          // Calculate a simple score
          let score = 0;

          // Soundex match gets highest score (check if they match)
          if (row.soundex_match) {
            score += 500;
          }

          // Substring match
          if (term.toLowerCase().includes(query.toLowerCase())) {
            score += 300;
          }

          // Similarity bonus (from database query)
          if (row.similarity_score > 0.5) score += 400;
          else if (row.similarity_score > 0.3) score += 200;

          // Distance penalty
          score -= distance * 50;

          // Frequency bonus (small)
          score += Math.log1p(frequency) * 10;

          if (score > 0) {
            allSuggestions.push({
              text: term,
              score,
              freq: frequency,
              distance,
            });
          }
        }
      } catch (error) {
        this.logger.warn(`‚ö†Ô∏è Failed to process field ${field}: ${error.message}`);
      }
    }

    // Sort by score and return top suggestions
    return allSuggestions.sort((a, b) => b.score - a.score).slice(0, 10);
  }

  /**
   * Build simple correction result
   */
  private buildSimpleCorrection(query: string, suggestions: Suggestion[]): TypoCorrection {
    if (!suggestions || suggestions.length === 0) {
      return this.buildEmptyCorrection(query);
    }

    // Find the best suggestion
    const bestSuggestion = suggestions[0];
    const correctedQuery = bestSuggestion.text;
    const confidence = Math.min(0.95, bestSuggestion.score / 200);  // More generous confidence calculation

    return {
      originalQuery: query,
      correctedQuery,
      confidence,
      suggestions,
      corrections: [
        {
          original: query,
          corrected: correctedQuery,
          confidence,
        },
      ],
    };
  }
}
